---
## Author
author:
  name: Ермолаев Алексей Максимович
  degrees: бакалавр
  orcid: нет
  email: vashermoalevalexey@gmail.com
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117228
      city: Москва
      address: ул. Пушкина, д. Колотушкина

## Title
title: "Лабораторная работа №5"
subtitle: "по дисциплине 'Математические основы защиты информации и информационной безопасности'"
license: "CC BY"
---

# Цель работы

Познакомиться с вероятностными алгоритмыми проверки числа на простоту.

# Задание

Реализуем алгоритм, реализующий тест Ферма, следующим образом:

```julia
using Random


function fermat_test(n::Integer, k::Integer=10)
    n ≤ 3 && return n == 2 || n == 3
    iseven(n) && return false
    
    for _ in 1:k
        a = rand(2:(n-2))
        if powermod(a, n-1, n) ≠ 1
            return false
        end
    end
    return true
end

#########################
num = 11
if fermat_test(num) == true
	result = "простое"
else
	result = "составное"
end
println("Число ", num, " - ", result)

############################
num = 228
if fermat_test(num) == true
	result = "простое"
else
	result = "составное"
end
println("Число ", num, " - ", result)
############################
```

Проверим результат его роаботы:

![Результат работы алгоритма.](image/img1.png){#fig-001 width=100%}

Реализуем алгоритм, реализующий тест Соловэя-Штрассена, включая нахождение символа Якоби, следующим образом:

```julia
function jacobi_symbol(a::Integer, n::Integer)
    a == 0 && return 0
    a == 1 && return 1
    
    g = 1
    local_a = a % n
    
    while local_a ≠ 0

        k = 0
        while iseven(local_a)
            local_a ÷= 2
            k += 1
        end
        

        if isodd(k)
            n_mod8 = n % 8
            if n_mod8 == 3 || n_mod8 == 5
                g = -g
            end
        end
        

        if (n % 4 == 3) && (local_a % 4 == 3)
            g = -g
        end
        

        local_a, n = n % local_a, local_a
    end
    
    return n == 1 ? g : 0
end


function solovay_strassen_test(n::Integer, k::Integer=10)
    n ≤ 3 && return n == 2 || n == 3
    iseven(n) && return false
    
    for _ in 1:k
        a = rand(2:(n-2))
        
        if gcd(a, n) > 1
            return false
        end
        

        r = powermod(a, (n-1)÷2, n)
        
        if r ≠ 1 && r ≠ n-1
            return false
        end
        

        s = jacobi_symbol(a, n)
        

        s_mod_n = s ≥ 0 ? s : s + n
        
        if r ≠ s_mod_n
            return false
        end
    end
    return true
end


#########################
num = 11
if solovay_strassen_test(num) == true
	result = "простое"
else
	result = "составное"
end
println("Число ", num, " - ", result)

############################
num = 228
if solovay_strassen_test(num) == true
	result = "простое"
else
	result = "составное"
end
println("Число ", num, " - ", result)
############################
```

Проверим результат его роаботы:

![Результат работы алгоритма.](image/img2.png){#fig-001 width=100%}

Реализуем алгоритм, реализующий тест Миллера-Рабина, следующим образом:

```julia
using Random


function fermat_test(n::Integer, k::Integer=10)
    n ≤ 3 && return n == 2 || n == 3
    iseven(n) && return false
    
    for _ in 1:k
        a = rand(2:(n-2))
        if powermod(a, n-1, n) ≠ 1
            return false
        end
    end
    return true
end


function miller_rabin_test(n::Integer, k::Integer=10)
    n ≤ 3 && return n == 2 || n == 3
    iseven(n) && return false
    
    s = 0
    r = n - 1
    while iseven(r)
        r ÷= 2
        s += 1
    end
    
    for _ in 1:k
        a = rand(2:(n-2))
        
        y = powermod(a, r, n)
        
        if y ≠ 1 && y ≠ n-1
            j = 1
            while j ≤ s-1 && y ≠ n-1
                y = powermod(y, 2, n)
                if y == 1
                    return false
                end
                j += 1
            end
            
            if y ≠ n-1
                return false
            end
        end
    end
    return true
end

#########################
num = 11
if fermat_test(num) == true
	result = "простое"
else
	result = "составное"
end
println("Число ", num, " - ", result)

############################
num = 228
if fermat_test(num) == true
	result = "простое"
else
	result = "составное"
end
println("Число ", num, " - ", result)
############################
```

Проверим результат его роаботы:

![Результат работы алгоритма.](image/img3.png){#fig-001 width=100%}

# Выводы

В рамках выполнения работы я познакомился с вероятностными алгоритмыми проверки числа на простоту.

# Список литературы{.unnumbered}

- **Менезес А., Ван Ооршот П., Ванстон С.** Справочник по прикладной криптографии / Пер. с англ. — М.: Вильямс, 2020. — 816 с. — ISBN 978-5-8459-2057-3.

- **Смарт Н.** Криптография: учебное пособие для вузов / Пер. с англ. — 2-е изд. — М.: Техносфера, 2018. — 528 с. — ISBN 978-5-94836-529-7.

- **Рябко Б.Я., Фионов А.Н.** Основы современной криптографии и стеганографии: учебное пособие. — М.: Горячая линия-Телеком, 2019. — 232 с. — ISBN 978-5-9912-0791-6.

- **Нечаев В.И.** Математические основы криптологии: учебное пособие. — М.: Гелиос АРВ, 2021. — 280 с. — ISBN 978-5-85438-275-7.

- **Бабаш А.В.**, Баранова Е.К. Криптография: учебник для вузов. — М.: КноРус, 2020. — 384 с. — ISBN 978-5-406-07821-7.
