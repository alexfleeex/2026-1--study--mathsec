---
## Author
author:
  name: Ермолаев Алексей Максимович
  degrees: бакалавр
  orcid: нет
  email: vashermoalevalexey@gmail.com
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117228
      city: Москва
      address: ул. Пушкина, д. Колотушкина

## Title
title: "Лабораторная работа №4"
subtitle: "по дисциплине 'Математические основы защиты информации и информационной безопасности'"
license: "CC BY"
---

# Цель работы

Познакомиться с алгоритмами нахождения наибольшего общего делителя.

# Задание

Реализуем алгоритм Евклида следующим образом:

```julia
function gcd_euclidian(a::Integer, b::Integer)
	a = abs(a)
	b = abs(b)

	a, b = max(a, b), min(a, b)
	
	while b != 0
		a, b = b, a % b
	end

	return a

end

num1, num2 = 6, 3
println("НОД(", num1, ";", num2, ")=", gcd_euclidian(num1, num2))

num1, num2 = 3, 6
println("НОД(", num1, ";", num2, ")=", gcd_euclidian(num1, num2))

num1, num2 = 1, 3
println("НОД(", num1, ";", num2, ")=", gcd_euclidian(num1, num2))

num1, num2 = 3, 1
println("НОД(", num1, ";", num2, ")=", gcd_euclidian(num1, num2))

num1, num2 = 0, 10
println("НОД(", num1, ";", num2, ")=", gcd_euclidian(num1, num2))

num1, num2 = 10, 0
println("НОД(", num1, ";", num2, ")=", gcd_euclidian(num1, num2))
```

Проверим результат работы:

![Результат работы алгоритма.](image/img1.png){#fig-001 width=100%}

Реализуем бинарный алгоритм Евклида следующим образом:

```julia
function is_even(a::Integer)
	return a % 2 == 0
end

function binary_gcd_euclidian(a::Integer, b::Integer)
	a = abs(a)
	b = abs(b)

	if a == 0 return b end
	if b == 0 return a end
	
	g = 1

	while is_even(a) && is_even(b)
		a ÷= 2
		b ÷= 2
		g *= 2
	end

	u, v = a, b

	while u != 0

		while is_even(u)
			u ÷= 2
		end

		while is_even(v)
			v ÷= 2
		end

		if u >= v
			u = u - v
		else
			v = v - u
		end
	end

	return g * v
	
end

num1, num2 = 6, 4
println("НОД(", num1, ";", num2, ")=", binary_gcd_euclidian(num1, num2))

num1, num2 = 3, 6
println("НОД(", num1, ";", num2, ")=", binary_gcd_euclidian(num1, num2))

num1, num2 = 1, 3
println("НОД(", num1, ";", num2, ")=", binary_gcd_euclidian(num1, num2))

num1, num2 = 3, 1
println("НОД(", num1, ";", num2, ")=", binary_gcd_euclidian(num1, num2))

num1, num2 = 0, 10
println("НОД(", num1, ";", num2, ")=", binary_gcd_euclidian(num1, num2))

num1, num2 = 10, 0
println("НОД(", num1, ";", num2, ")=", binary_gcd_euclidian(num1, num2))
```

Проверим результат работы:

![Результат работы алгоритма.](image/img2.png){#fig-001 width=100%}

Реализуем расширенный алгоритм Евклида следующим образом:

```julia
function extended_gcd_euclidian(a::Integer, b::Integer)
	a, b = abs(a), abs(b)
	if a == 0 return (b, 0, 1) end
	if b == 0 return (a, 1, 0) end

		
	if a < b
		is_permuted = true
		a, b = b, a
	else
		is_permuted = false
	end

	r_prev, r_curr = a, b
	x_prev, x_curr = 1, 0
	y_prev, y_curr = 0, 1

	while r_curr != 0
		q = r_prev ÷ r_curr
		r_next = r_prev % r_curr

		x_next = x_prev - q * x_curr
		y_next = y_prev - q * y_curr

		r_prev, r_curr = r_curr, r_next
		x_prev, x_curr = x_curr, x_next
		y_prev, y_curr = y_curr, y_next
		
	end	

	if is_permuted
		return (r_prev, y_prev, x_prev)
	else
		return (r_prev, x_prev, y_prev)
	end
end

num1, num2 = 6, 4
g, x, y = extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
println(x, "*", num1, "+", y, "*", num2, "=", g)
println()

num1, num2 = 4, 6
g, x, y = extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
println(x, "*", num1, "+", y, "*", num2, "=", g)
println()

num1, num2 = 1, 3
g, x, y = extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
println(x, "*", num1, "+", y, "*", num2, "=", g)
println()

num1, num2 = 3, 1
g, x, y = extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
println(x, "*", num1, "+", y, "*", num2, "=", g)
println()

num1, num2 = 0, 10
g, x, y = extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
println(x, "*", num1, "+", y, "*", num2, "=", g)
println()

num1, num2 = 10, 0
g, x, y = extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
println(x, "*", num1, "+", y, "*", num2, "=", g)
println()
```

Проверим результат работы:

![Результат работы алгоритма.](image/img3.png){#fig-001 width=100%}

Реализуем расширенный бинарный алгоритм Евклида следующим образом:

```julia
function is_even(a::Integer)
	return a % 2 == 0
end

function binary_extended_gcd_euclidian(a::Integer, b::Integer)

    a, b = abs(a), abs(b)
	if a == 0 return (b, 0, 1) end
	if b == 0 return (a, 1, 0) end


    a_orig, b_orig = a, b
    
    g = 1

    while is_even(a) && is_even(b)
        a ÷= 2
        b ÷= 2
        g *= 2
    end
    
    u, v = a, b
    A, B, C, D = 1, 0, 0, 1
    
    while u != 0
        
        while is_even(u)
            u ÷= 2
            
            if is_even(A) && is_even(B)
                A ÷= 2
                B ÷= 2
            else
                A = (A + b_orig) ÷ 2
                B = (B - a_orig) ÷ 2
            end
        end
        
        while is_even(v)
            v ÷= 2
            
            if is_even(C) && is_even(D)
                C ÷= 2
                D ÷= 2
            else
                C = (C + b_orig) ÷ 2
                D = (D - a_orig) ÷ 2
            end
        end
        
        if u >= v
            u = u - v
            A = A - C
            B = B - D
        else
            v = v - u
            C = C - A
            D = D - B
        end
    end
    
   
    d = g * v
    x, y = C, D

    return (d, x, y)
    
end

num1, num2 = 6, 4
g, x, y = binary_extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
# println(x, "*", num1, "+", y, "*", num2, "=", g)
println()

num1, num2 = 4, 6
g, x, y = binary_extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
# println(x, "*", num1, "+", y, "*", num2, "=", g)
println()

num1, num2 = 1, 3
g, x, y = binary_extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
# println(x, "*", num1, "+", y, "*", num2, "=", g)
println()

num1, num2 = 3, 1
g, x, y = binary_extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
# println(x, "*", num1, "+", y, "*", num2, "=", g)
println()

num1, num2 = 0, 10
g, x, y = binary_extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
# println(x, "*", num1, "+", y, "*", num2, "=", g)
println()

num1, num2 = 10, 0
g, x, y = binary_extended_gcd_euclidian(num1, num2)
println("НОД(", num1, ";", num2, ")=", g)
# println(x, "*", num1, "+", y, "*", num2, "=", g)
println()
```

Проверим результат работы:

![Результат работы алгоритма.](image/img4.png){#fig-001 width=100%}

# Выводы

В рамках выполнения работы я познакомился с алгоритмами нахождения наибольшего общего делителя.

# Список литературы{.unnumbered}

- **Менезес А., Ван Ооршот П., Ванстон С.** Справочник по прикладной криптографии / Пер. с англ. — М.: Вильямс, 2020. — 816 с. — ISBN 978-5-8459-2057-3.

- **Смарт Н.** Криптография: учебное пособие для вузов / Пер. с англ. — 2-е изд. — М.: Техносфера, 2018. — 528 с. — ISBN 978-5-94836-529-7.

- **Рябко Б.Я., Фионов А.Н.** Основы современной криптографии и стеганографии: учебное пособие. — М.: Горячая линия-Телеком, 2019. — 232 с. — ISBN 978-5-9912-0791-6.

- **Нечаев В.И.** Математические основы криптологии: учебное пособие. — М.: Гелиос АРВ, 2021. — 280 с. — ISBN 978-5-85438-275-7.

- **Бабаш А.В.**, Баранова Е.К. Криптография: учебник для вузов. — М.: КноРус, 2020. — 384 с. — ISBN 978-5-406-07821-7.
